<!DOCTYPE html>
<!-- 1번 : HTML5 문서임을 선언하는 코드 (웹 브라우저에게 최신 문법 사용을 알림)-->

<html lang="en">
<!-- 2번 : 이 문서의 언어가 영어임을 표시, 한글 설명이 많다면 lang="ko"로-->

<head>
  <meta charset="UTF-8" />
  <!-- 3번 : 문자 인코딩을 UTF-8로 설정 (한글 포함 다양한 언어를 지원)-->

  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <!-- 4번 : 화면 크기에 맞게 웹페이지를 조절하여 보여줌 (모바일 기기 대응용)-->
  <!-- meta
   메타 태그는 웹페이지의 정보를 브라우저나 검색엔진에게 알려주는 태그입니다.
   실제로 화면에 보이지는 않지만, 기능적으로 매우 중요합니다.
   ✅ name="viewport"
   viewport는 사용자가 보는 웹페이지의 보이는 영역(화면 창) 을 의미합니다.
   이 설정은 화면 크기에 따라 웹페이지가 어떻게 보일지를 조절합니다.
   ✅ content="width=devide-width"
   이 부분은 웹페이지의 너비를 사용자가 기기 너비에 맞춘다는 의미입니다.
   예 : 아이폰, 갤럭시 같은 스마트폰의 실제 너비에 맞게 페이지를 자동으로 맞춤.
   ✅ initial-scale=1.0
   **처음 화면을 볼 때의 확대 비율(줌 레벨)**을 1로 설정합니다.
   1.0은 원래 크기, 즉 확대나 축소 없이 화면을 그대로 보여준다는 뜻입니다.
   만약 2.0이라면 처음부터 2배 확대된 상태로 보이게 됩니다.-->

  <title>Web Animation(canvas_js_css)[1단원-1]</title>
  <!-- 5번 : 웹 브라우저 탭에 보이는 제목 설정 -->
  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      font-family: sans-serif;
    }
    /* 주석문작성 : body(전체 페이지) 기본 설정:
      - 바깥 여백(margin)과 안쪽 여백(padding) 제거
      - 안의 글자나 요소를 가운데 정렬
      - 글꼴은 기본 산세리프(획이 없는 깔끔한 글꼴) 로 설정*/

            
    #canvas {
      background: #DCD7C9;
      display: block;
      margin: 0 auto; 
    }
     /*6번  : id가 canvas인 요소(캔버스 박스) 의 기본 스타일:
     - 배경색은 연한 베이지색 (#DCD7C9)
     - block형으로 만들어서 가운데 정렬이 가능하게 함
     - margin을 auto로 설정하여 가로 중앙에 배치 */

    #replayBtn {
      position: absolute;
      font-size: 30px; /* 폰트 크기*/
      top: 300px; /* 위쪽여백 300px*/
      left: 400px; /* 왼쪽여백 470px*/
      width: 200px; /* 가로 크기*/
      height: 60px; /* 세로 크기*/
    }

     .pc-guide{
        display: none; /* 화면에 보이지 않게함*/
        margin-top: 10px; /* 위쪽여백*/
        font-size: 16px; /* 버튼 글자크기*/
        color: #333; /* 글자색*/
        font-weight: bold; /*글자굵게*/
     }

    /* PC에서는 600x600 고정 */
    @media (min-width: 769px) {
      #canvas {
        width: 600px;
        height: 600px;
      }

      .pc-guide{
        display: block; /* pc-guide를 PC에서 접속시 보이게함 */
      }
    }
    /* 주석문 작성 : 화면이 769픽셀보다 넓은 (주로 PC) 환경에서는
    캔버스 크기를 600x600 픽셀로 고정함 */

    /* 버튼들을 감싸는 div 숨기기 (PC에서는 안 보이게하고 스마트폰에서 접속이 보임)*/
    .controls {
        display: none; /*화면에 보이지 않게함*/
        margin-top: 10px; /* 위쪽 즉 캔버스하고 여백을 10픽셀 줌*/
    }

    /* 스마트폰에서 보여질 버튼 모양 설정*/
    .controls button {
        font-size: 18px; /* 버튼 글자크기*/
        padding: 10px 20px; /* 안쪽여백 : 위아래 좌우여백*/
        margin: 5px; /* 버튼 바깥쪽 여백을 5픽셀 줌*/
    }


    /* 화면이 작을 때 (스마트폰 등에서 보인다면 아래 코드동작)
    화면의 폭이 최대 768 픽셀보다 아래라면 아래 css동작함 아니면 위 PC용 CSS @media (min-width: 769px) 동작함
    어 최근 스마트폰의 해상도는 PC보다도 좋은 경우가 많은데 768 픽셀보다 작으면 스마트폰이라니?
    이유 : 스마트폰의 물리적인 해상도는 더 크지만, 화면을 작게 보이도록 하기 위해 **디바이스 픽셀 비율(DPR, devicePixelRatio)**을 사용함
    아이폰13의 가로해상도가 1170픽셀인데 CSS픽셀로는 1170/3= 390픽셀임
    현재 기기로 보아도 768 CSS픽셀이면 모든 스마트폰에서 접속하는 것으로 판단함*/

    @media (max-width: 768px) {
        #canvas {
            width: 100vw; /* 스마트폰 화면 canvas 가로 전체 크기로함 */
            height: 100vw; /* 화면 canvas_ 세로 = 가로 (정사각형) */
        }
        .controls {
            display: block; /* 스마트폰에서 접속시 controls을 보이게함 */
        }
        .pc-guide {
            display: none; /* pc-guide를 스마트폰 접속시 숨김 */
        }
        
    }

    /* 
        @media (min-width: 769px)
        이것은 **미디어 쿼리(Media Query)**라고 해요.
        "화면의 가로 길이(width)가 769픽셀 이상일 때만" 아래 스타일을 적용하라는 뜻입니다.
        즉, 화면이 클 경우 (태블릿, 노트북, PC 등) 이 조건이 참이 됩니다.
        참고:
        스마트폰 대부분은 가로 길이가 768px 이하
        태블릿부터는 보통 769px 이상

        #canvas { width:  600px; height: 600px; }
        조건이 맞을 때(min-width: 769px), 이 안의 CSS가 실행됩니다.
        즉, 캔버스의 크기를 너비 600px, 높이 600px로 고정합니다.
        큰 화면(PC나 태블릿) 에서는 정사각형(600x600)의 고정된 캔버스를 보게 됩니다.

        왜 이렇게 할까?
        웹사이트는 **다양한 화면 크기(스마트폰, 태블릿, 노트북 등)**에서 잘 보여야 합니다.
        그래서 미디어 쿼리를 사용해서 화면 크기에 따라 다른 디자인을 적용할 수 있게 설정하게 됩니다.
    */

  </style>
</head>        
</body>
    <canvas id="canvas"></canvas> <!-- 7번 : 화면에 캔버스 (그림판) 생성-->
    <!-- 주석문작성 : 그림이나 애니메이션을 그릴 수 있는 HTML 캔버스 id가 canvas인 요소 추가-->

    <!-- 애니메이션 화면 만들기 : 스마트폰에서 접속 할 때만 controls이 보이게됨-->
     <div class="controls">
        <button id="leftBtn">◁</button>
        <button id="rightBtn">▷</button>
        <button id="upBtn">△</button>
        <button id="downBtn">▽</button>
     </div>

     <!-- PC 전용 안내 문구 -->
      <div class="pc-guide">
        PC에서 접속했습니다. 방향키로 이동하세요.<br>
        스마트폰에서 접속 시 보이는 버튼으로 이동하세요.
        
      </div>
      <div class="replayBtn">
        <button id="replayBtn">재도전</button>
      </div>


  <script> 

    // 8번 : 자바스크립트 코드 실행 시작

    const drawingBoard = document.getElementById('canvas'); // 9번: 캔버스 요소를 JS변수로 가져오기
    const drawingPen = drawingBoard.getContext('2d'); // 10번: 2D로 그림 그릴 수 있는 도구 설정

    // 캔버스 크기를 CSS와 맞춰줌 
    // 아래처럼 하면 PC는 600x600으로 설정되고 스마트폰은 360x360으로 화면계산됨
    //drawingBoard.width = drawingBoard.clientWidth; // 11번: 실제 캔버스 너비를 CSS와 일치시킴
    //drawingBoard.height = drawingBoard.clientHeight; // 12번: 실제 캔버스 높이도 맞춰줌
    // 캔버스 내부 해상도는 무조건 600x600 고정(PC, 스마트폰 모두)
    drawingBoard.width = 600;
    drawingBoard.height = 600;

    let x = (20); // 13번: 사각형의 시작 위치
    let y = (570);

    const moveAmount = 5; // 14번: 방향키 누를 때 이동할 거리(5픽셀)

    let collision_value = [5]; // 충돌변수 초기값을 0으로지정
    for(i=0;i<5;i++){
      collision_value [i] = 0;
    }

    let collision_value2 = [5]; // 충돌변수 초기값을 0으로지정
    for(i=0;i<5;i++){
      collision_value2 [i] = 0;
    }

    enemy_switch = [5];
    for(i=0;i<5;i++){
      enemy_switch [i] = 1;
    }


    let millisecond = 0; //밀리초  초기값을 0으로 지정
    let Timer_value = 0; //초 값을 0으로 지정

    let square_count = 5; //적사각형 남은 개수 초기값을 5로 지정

    let progress_status = 0; // 게임 진행상황 초기값 0으로 지정 1은 종료

    const enemyX = [5];
    const enemyY = [5];

    //15번: 각각의 방향으로 이동하는함수들
    function moveRight(){
        x = x + moveAmount;
    }

    function moveLeft(){
        x = x - moveAmount;
    }

    function moveDown(){
        y = y + moveAmount;
    }

    function moveUp(){
        y = y - moveAmount;
    }

    // 1_4 주인공 이동제한
    function move_limit(){
      if (x < 0){//왼쪽이동제한
        x = 0;
      }
      if (x > 590){//오른쪽이동제한
        x = 590;
      }
      if (y < 0){//위쪽이동제한
        y = 0;
      }
      if (y > 590){//위쪽이동제한
        y = 590;    
      }
    }

    function collision1(){ // 충돌검사 충돌하면 충돌변수에 1 저장
      for (i=0;i<5;i++){
        if (enemy_switch [i] == 1){
        if ((x+10)>enemyX [i] && (y+10)>enemyY [i] && x<(enemyX [i]+20) && y<(enemyY [i]+20)){
          collision_value [i] = 1; 
          collision_value2 [i] = 1;
          enemy_switch [i] = 0;
        }
        }
      } 
    }

    function decrease_square(){ // 적사각형 남은 개수 감소하는 함수
      for (i=0;i<5;i++){
        if (collision_value2 [i] == 1){
        square_count --;
        collision_value2 [i] = 0;
        }
      }
    }


    function enemy_random(){ // 난수출력
        for(i=0;i<5;i++){
          enemyX [i] = 20 + Math.floor(Math.random() * (570 - 20 + 1));
          enemyY [i] = 50 + Math.floor(Math.random() * (570 - 50 + 1));
        }
    }

    enemy_random(); // 적사각형 xy 좌표 난수 함수 호출 

    function Timer(){ // 시간출력 함수
      if(progress_status == 0){
      millisecond ++;
      if (millisecond == 60){
        Timer_value ++;
        millisecond = 0;
      }
      }
    }

    function reload(){ // 페이지 새로고침 함수
      location.reload(true);
    }

    function hide_replayBtn(){ /* 재도전 버튼 숨기기 */
      if(progress_status == 0){
         document.getElementById("replayBtn").style.display = 'none';
      }
      else {
        document.getElementById("replayBtn").style.display = 'block';
      }
    }



    // 1_4 : 캔버스 왼쪽 상단에 텍스트 출력함수
    function drawCoordinate(){
        drawingPen.fillStyle = 'black';
        drawingPen.font = '10px sans-serif';
        drawingPen.fillText(`x: ${x} y : ${y}`, 10, 20); //1_4 주인공 좌표출력
    }

    function draw_Timer(){ // 타이머를 출력하는 함수
      drawingPen.fillStyle = 'black';
      drawingPen.font = '20px sans-serif';
      drawingPen.fillText(`${Timer_value}:${millisecond}초`, 290, 30);
    }

    function draw_square_count(){ // 남은 적사각형 개수를 출력하는 함수
      drawingPen.fillStyle = 'black';
      drawingPen.font = '20px sans-serif';
      drawingPen.fillText(`RED no ${square_count}`, 400, 30);
    }
    //16번: 주인공(검정 사각형)을 그리는 함수
    function drawHero(){
        drawingPen.fillStyle = 'black';
        drawingPen.fillRect(x, y, 10, 10);
    }
    //적을 그리는 함수
    function enemy1(){
      for (i=0;i<5;i++){
        if(collision_value [i] == 0){
          drawingPen.fillStyle = 'red';
          drawingPen.fillRect(enemyX [i], enemyY [i], 20,20);
        }
      }
    }

    function Gameover(){ // 게임종료 함수 
      if(square_count == 0){
      drawingPen.fillStyle = 'red';
      drawingPen.font = '35px sans-serif';
      drawingPen.fillText(`미션해결 시간 ${Timer_value}:${millisecond}초`, 200, 275);
      progress_status = 1;
      }
    }

    //17번: 화면을 지우고 주인공을 다시 그림
    function draw(){
        drawingPen.fillText(`x: ${x} y: ${y}`, 10, 20);// 1_4 : 캔버스 왼쪽 상단에 텍스트출력
        drawingPen.clearRect(0,0, canvas.width, canvas.height);
        drawHero(); // 새 위치에 주인공 그리기
        enemy1(); // 적 출력 함수호출
        move_limit(); //1_4 : 주인공 이동제한 함수호출
        drawCoordinate(); // 1_4 : 텍스트 출력 함수 호출
        draw_Timer(); //타이머 출력 함수 호출
        collision1(); //충돌검사 함수호출
        Timer(); // 타이머 함수 호출
        draw_square_count(); // 적사각형 남은개수 출력 함수 호출
        decrease_square(); // 적사각형 감소 함수 호출
        Gameover(); // 게임 종료 함수 호출
        hide_replayBtn(); // 재도전 버튼 함수 호출
    }

            
    //18번: 1초에 60번 반복해서 draw 함수 실행 (움직임을 부드럽게 보여줌)

    setInterval(draw, 16); // 60 FPS

    // 19번 : 키보드를 누르면 해당 방향으로 이동하게 함
    document.addEventListener('keydown', (e) => {
    // 눌린 키(e.key)가 무엇인지 확인해서 아래 명령 실행
        switch (e.key) {
            case 'ArrowLeft' : moveLeft(); break; // 왼쪽 화살표 눌렀을 떄
            case 'ArrowRight' : moveRight(); break; // 오른쪽 화살표 눌렀을 때
            case 'ArrowUp' : moveUp(); break; // 위쪽 화살표 눌렀을 때
            case 'ArrowDown' : moveDown(); break; // 아래쪽 화살표 눌렀을 때
        }
    }
    );

    // 버튼 이벤트 연결 : 버튼을 선택하면 해당 함수를 호출해서 주인공 이동
    //  document : 현재 웹 페이지 전체를 의미
    //  hetElemenByld('leftBtn') : 웹 페이지에서 id가 leftBtn인 **버튼**을 의미
    //  addEventListener : "어떤 일이 일어났을 때" 실행할 코드를 지정해주는 함수
    //  'click' : 버튼을 마우스로 클릭했을 때 실행하라는 뜻임
    //  moveLeft : 클릭하면 moveLeft함수를 호출함
    document.getElementById('leftBtn').addEventListener('click', moveLeft);
    document.getElementById('rightBtn').addEventListener('click', moveRight);
    document.getElementById('upBtn').addEventListener('click', moveUp);
    document.getElementById('downBtn').addEventListener('click', moveDown);
    document.getElementById('replayBtn').addEventListener('click', reload);

    </script>
</body>
</html>
<!-- 주석문작성 : HTML 문서 끝-->
 <!-- html 이란? 
  웹사이트의 모습을 기술하기 위한 마크업 언어

  html5란?
  웹 페이지를 구성하기 위한 마크업 언어의 최신 표준

  canvas란?
  오픈 소스 학습 관리 시스템

  css란?
  html 등의 마크업 언어로 작성된 문서가 실제로 웹사이트에 표현되는 방법을 정해주는 스타일시트 언어

  반응형 홈페이지란?
  다양한 크기의 화면 (PC, 태블릿, 스마트폰 등) 에서 최적화된 화면 구성으로 보이는 웹페이지 -->

  <!-- 웹 호스팅이란?
   웹사이트의 파일, 데이터, 콘텐츠 등을 인터넷 서버에 저장하고 사용자들이 웹 브라우저를 통해 접속할 수 있도록 서비스를 제공하는 것을 의미
   URL이란?
   웹에서 특정 리소스(웹페이지, 이미지, 비디오 등)의 위치를 나타내는 주소
   IP주소란?
   IP 통신에 필요한 고유 주소
   도메인네임이란?
   인터넷에서 웹 사이트를 식별하고 접근하는 데 사용되는 문자열
   -->
