    <!DOCTYPE html>
    <!-- 1번 : HTML5 문서임을 선언하는 코드 (웹 브라우저에게 최신 문법 사용을 알림)-->

    <html lang="en">
    <!-- 2번 : 이 문서의 언어가 영어임을 표시, 한글 설명이 많다면 lang="ko"로-->

    <head>
      <meta charset="UTF-8" />
      <!-- 3번 : 문자 인코딩을 UTF-8로 설정 (한글 포함 다양한 언어를 지원)-->

      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <!-- 4번 : 화면 크기에 맞게 웹페이지를 조절하여 보여줌 (모바일 기기 대응용)-->
      <!-- meta
      메타 태그는 웹페이지의 정보를 브라우저나 검색엔진에게 알려주는 태그입니다.
      실제로 화면에 보이지는 않지만, 기능적으로 매우 중요합니다.
      ✅ name="viewport"
      viewport는 사용자가 보는 웹페이지의 보이는 영역(화면 창) 을 의미합니다.
      이 설정은 화면 크기에 따라 웹페이지가 어떻게 보일지를 조절합니다.
      ✅ content="width=devide-width"
      이 부분은 웹페이지의 너비를 사용자가 기기 너비에 맞춘다는 의미입니다.
      예 : 아이폰, 갤럭시 같은 스마트폰의 실제 너비에 맞게 페이지를 자동으로 맞춤.
      ✅ initial-scale=1.0
      **처음 화면을 볼 때의 확대 비율(줌 레벨)**을 1로 설정합니다.
      1.0은 원래 크기, 즉 확대나 축소 없이 화면을 그대로 보여준다는 뜻입니다.
      만약 2.0이라면 처음부터 2배 확대된 상태로 보이게 됩니다.-->

      <title>Web Animation(canvas_js_css)[1단원-1]</title>
      <!-- 5번 : 웹 브라우저 탭에 보이는 제목 설정 -->
      <style>
        body {
          margin: 0;
          padding: 0;
          text-align: center;
          font-family: sans-serif;
        }
        /* 주석문작성 : body(전체 페이지) 기본 설정:
          - 바깥 여백(margin)과 안쪽 여백(padding) 제거
          - 안의 글자나 요소를 가운데 정렬
          - 글꼴은 기본 산세리프(획이 없는 깔끔한 글꼴) 로 설정*/

                
        #canvas {
          background: #DCD7C9;
          display: block;
          margin: 0 auto; 
        }
        /*6번  : id가 canvas인 요소(캔버스 박스) 의 기본 스타일:
        - 배경색은 연한 베이지색 (#DCD7C9)
        - block형으로 만들어서 가운데 정렬이 가능하게 함
        - margin을 auto로 설정하여 가로 중앙에 배치 */

        #replayBtn {
          position: absolute;
          font-size: 30px; /* 폰트 크기*/
          top: 30%; /* 위쪽여백 300px*/
          left: 45%; /* 왼쪽여백 470px*/
          width: 200px; /* 가로 크기*/
          height: 60px; /* 세로 크기*/
        }

        #startBtn {
          position: absolute;
          font-size: 30px;
          top: 30%;
          left: 45%;
          width: 200px;
          height: 60px;
        }

        #startBtn:hover {
          background: #45a049;
          transform: scale(1.05);
        }

        .messageBox {
          display: none;
          position: absolute;
          top: 30%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: #fff;
          border: 2px solid #333;
          padding: 20px;
          z-index: 10;
        }


        .pc-guide{
            display: none; /* 화면에 보이지 않게함*/
            margin-top: 10px; /* 위쪽여백*/
            font-size: 16px; /* 버튼 글자크기*/
            color: #333; /* 글자색*/
            font-weight: bold; /*글자굵게*/
        }

        /* PC에서는 600x600 고정 */
        @media (min-width: 769px) {
          #canvas {
            width: 600px;
            height: 600px;
          }

          .pc-guide{
            display: block; /* pc-guide를 PC에서 접속시 보이게함 */
          }
        }
        /* 주석문 작성 : 화면이 769픽셀보다 넓은 (주로 PC) 환경에서는
        캔버스 크기를 600x600 픽셀로 고정함 */

        /* 버튼들을 감싸는 div 숨기기 (PC에서는 안 보이게하고 스마트폰에서 접속이 보임)*/
        .controls {
            display: none; /*화면에 보이지 않게함*/
            margin-top: 10px; /* 위쪽 즉 캔버스하고 여백을 10픽셀 줌*/
        }

        /* 스마트폰에서 보여질 버튼 모양 설정*/
        .controls button {
            font-size: 18px; /* 버튼 글자크기*/
            padding: 10px 20px; /* 안쪽여백 : 위아래 좌우여백*/
            margin: 5px; /* 버튼 바깥쪽 여백을 5픽셀 줌*/
        }


        /* 화면이 작을 때 (스마트폰 등에서 보인다면 아래 코드동작)
        화면의 폭이 최대 768 픽셀보다 아래라면 아래 css동작함 아니면 위 PC용 CSS @media (min-width: 769px) 동작함
        어 최근 스마트폰의 해상도는 PC보다도 좋은 경우가 많은데 768 픽셀보다 작으면 스마트폰이라니?
        이유 : 스마트폰의 물리적인 해상도는 더 크지만, 화면을 작게 보이도록 하기 위해 **디바이스 픽셀 비율(DPR, devicePixelRatio)**을 사용함
        아이폰13의 가로해상도가 1170픽셀인데 CSS픽셀로는 1170/3= 390픽셀임
        현재 기기로 보아도 768 CSS픽셀이면 모든 스마트폰에서 접속하는 것으로 판단함*/

        @media (max-width: 768px) {
            #canvas {
                width: 100vw; /* 스마트폰 화면 canvas 가로 전체 크기로함 */
                height: 100vw; /* 화면 canvas_ 세로 = 가로 (정사각형) */
            }
            .controls {
                display: block; /* 스마트폰에서 접속시 controls을 보이게함 */
            }
            .pc-guide {
                display: none; /* pc-guide를 스마트폰 접속시 숨김 */
            }
            
        }

        /* 
            @media (min-width: 769px)
            이것은 **미디어 쿼리(Media Query)**라고 해요.
            "화면의 가로 길이(width)가 769픽셀 이상일 때만" 아래 스타일을 적용하라는 뜻입니다.
            즉, 화면이 클 경우 (태블릿, 노트북, PC 등) 이 조건이 참이 됩니다.
            참고:
            스마트폰 대부분은 가로 길이가 768px 이하
            태블릿부터는 보통 769px 이상

            #canvas { width:  600px; height: 600px; }
            조건이 맞을 때(min-width: 769px), 이 안의 CSS가 실행됩니다.
            즉, 캔버스의 크기를 너비 600px, 높이 600px로 고정합니다.
            큰 화면(PC나 태블릿) 에서는 정사각형(600x600)의 고정된 캔버스를 보게 됩니다.

            왜 이렇게 할까?
            웹사이트는 **다양한 화면 크기(스마트폰, 태블릿, 노트북 등)**에서 잘 보여야 합니다.
            그래서 미디어 쿼리를 사용해서 화면 크기에 따라 다른 디자인을 적용할 수 있게 설정하게 됩니다.
        */

      </style>



<script>
window.addEventListener('load', () => {
    const userIdInput = document.getElementById('userId');
    const saveBtn = document.getElementById('saveBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const msgBox = document.getElementById('msgBox');

    saveBtn.addEventListener('click', async () => {
        const val = userIdInput.value.trim();

        // ID 형식 검사 (영어+숫자, 5~10자)
        const re = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z0-9]{5,10}$/;
        if(!re.test(val)){
            alert('아이디는 영어와 숫자를 반드시 포함한 5~10자여야 합니다.');
            userIdInput.focus();
            return;
        }

        alert(`입력한 아이디는 ${val}입니다.`);

        try{
            const db = window.__db;
            if(!db){ alert("DB 초기화 실패!"); return; }

            const { collection, addDoc, serverTimestamp } = await import(
              "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js"
            );

            const stopTime = Timer_value + millisecond / 60;
            const record = Number(stopTime.toFixed(2));

            await addDoc(collection(db, "scores"), {
                userId: val,
                time: record,
                createdAt: serverTimestamp()
            });

            alert(`저장되었습니다!\nID: ${val}\n기록: ${record}초`);
            msgBox.style.display = 'none';
            location.href = "canvas_js_exam_1_11_rankpage.html";

        } catch(err){
            console.error(err);
            alert("저장 중 오류 발생!");
        }
    });

    cancelBtn.addEventListener('click', () => {
        msgBox.style.display = 'none';
        location.reload();
    });
});
</script>



        


      <!-- 1_10 : Firebase SDK (모듈)-->
      <script type="module">
          // 1_10 : Firebase v9 이상 버전에서는 이런 식으로 "모듈"을 가져와야 함
          // 1_10 : (import는 외부에서 만든 기능을 내 코드 안으로 불러오는 명령)

          // 1_10 : Firebase의 기본 기능(앱 초기화 기능)을 불러옴 : Firebase를 내 웹페이지 안에서 사용할 수 있게 준비하는 기능
          import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
          // 1_10 : Firestore(파이어스토어)라는 데이터 저장소 관련 기능들을 불러옴
          // 1_10 : - getFirestore       : 데이터베이스 연결 기능
          // 1_10 : - collection         : 데이터를 모아두는 '폴더' 역할 (ex. "scores" 폴더)
          // 1_10 : - addDoc             : 실제 데이터를 폴더 안에 추가하는 기능 (ex. 점수 저장)
          // 1_10 : - serverTimestamp    : 저장할 때 서버의 현재 시간을 자동으로 기록하는 기능
          import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";


          // 1_10 : 본인 firebase 프로젝트 설정으로 교체
          // 1_10 : 아래 값들을 가져오는 위치는 1단원-9의 6단계를 참고하면 어디에 위치하고 있는지 알수 있다
          // 1_10 : 자신의 값을 가져오면 된다. 아래 값은 프로젝트마다 다르다.
          // 1_10 : 프로젝트마다 다르므로 현재 만들고 있는 프로젝트의 내용을 복사해야 해당 DB에 저장된다.
          // 1_10 : apiKey: -> Firebase 프로젝트에 연결하기 위한 비밀 열쇠 (접속용 키)

          // 1_10 : authDomain: -> 로그인 등 인증에 사용되는 Firebase 전용 주소
          // 1_10 : projectId: -> Firebase에서 만든 프로젝트의 고유 이름 (ID)
          // 1_10 : storageBucket: -> 파일(이미지, 음악 등)을 저장하는 구글 클라우드 참고 주소
          // 1_10 : messagingSenderId: -> 알림(Firebase Cloud Messaging) 보낼 때 쓰는 발산자 ID
          // 1_10 : appId: -> 내 웹앱을 구별하기 위한 고유번호 (Firebase 내부에서 구분용)
          const firebaseConfig = {
              apiKey: "AIzaSyAHpiAjF8_X2OgmIRXXWxq5qinoVa07S8M",
              authDomain: "my-webgame-project1-2b57b.firebaseapp.com",
              projectId: "my-webgame-project1-2b57b",
              storageBucket: "my-webgame-project1-2b57b.firebasestorage.app",
              messagingSenderId: "123464054285",
              appId: "1:123464054285:web:c3a3ac957cde3169a8c744"
          };
          // 1_10 : Firebase 초기화
          // 1_10 : Firebase에 "내 프로젝트 정보(firebaseConfig)"를 연결해서 이 웹페이지가 내 Firebase 프로젝트와 통신할 수 있게 만듦
          const app = initializeApp(firebaseConfig);
          // 1_10 : Firestore(파이어스토어, 데이터 저장소)와 연결함 즉, 내가 데이터를 저장하고 불러올 수 있는 'DB(Datebase)' 준비
          const db = getFirestore(app);

          // 1_10 : 전역(window)에 등록하기
          // 1_10 : -> 이 파일 아래쪽의 다른 코드에서도 'db'를 쓸 수 있게
          // 1_10 : window.__db 라는 이름으로 전역에 저장해 둠
          // 1_10 : (예 : 저장 버튼 클릭할 때 window.__db 로 접근 가능)
          window.__db = db;
          </script>
    </head>        
    <body>
        <canvas id="canvas"></canvas> <!-- 7번 : 화면에 캔버스 (그림판) 생성-->
        <!-- 주석문작성 : 그림이나 애니메이션을 그릴 수 있는 HTML 캔버스 id가 canvas인 요소 추가-->

        <!-- 애니메이션 화면 만들기 : 스마트폰에서 접속 할 때만 controls이 보이게됨-->
        <div class="controls">
            <button id="leftBtn">◁</button>
            <button id="rightBtn">▷</button>
            <button id="upBtn">△</button>
            <button id="downBtn">▽</button>
        </div>

        <!-- PC 전용 안내 문구 -->
          <div class="pc-guide">
            PC에서 접속했습니다. 방향키로 이동하세요.<br>
            스마트폰에서 접속 시 보이는 버튼으로 이동하세요.
            
          </div>
          <div class="replayBtn">
            <button id="replayBtn">재도전</button>
          </div>

        <div class="startBtn">
          <button id="startBtn">시작</button>
        </div>

        <div class="messageBox" id="msgBox">
          <div id="msgText"></div>
          <input type="text" id="userId" placeholder="(영어+숫자) 5~15자이내">
          <br>
          <button id="saveBtn">저장</button>
          <button id="cancelBtn">취소</button>
        </div>

        


      <script> 

        // 8번 : 자바스크립트 코드 실행 시작

        const drawingBoard = document.getElementById('canvas'); // 9번: 캔버스 요소를 JS변수로 가져오기
        const drawingPen = drawingBoard.getContext('2d'); // 10번: 2D로 그림 그릴 수 있는 도구 설정

        // 캔버스 크기를 CSS와 맞춰줌 
        // 아래처럼 하면 PC는 600x600으로 설정되고 스마트폰은 360x360으로 화면계산됨
        //drawingBoard.width = drawingBoard.clientWidth; // 11번: 실제 캔버스 너비를 CSS와 일치시킴
        //drawingBoard.height = drawingBoard.clientHeight; // 12번: 실제 캔버스 높이도 맞춰줌
        // 캔버스 내부 해상도는 무조건 600x600 고정(PC, 스마트폰 모두)
        drawingBoard.width = 600;
        drawingBoard.height = 600;

        let x = 20; // 13번: 사각형의 시작 위치
        let y = 570;

        const moveAmount = 5; // 14번: 방향키 누를 때 이동할 거리(5픽셀)

        let collision_value = []; // 적사각형1 충돌변수 초기값을 1로지정
        for(i=0;i<10;i++){
          collision_value [i] = 1;
        }

        let collision_value2 = []; // 적사각형2 충돌변수 초기값을 1로지정
        for(i=10;i<15;i++){
          collision_value2 [i] = 1;
        }


        let decrease = []; // 적사각형개수 감소 변수
        for(i=0;i<10;i++){
          decrease [i] = 0;
        }

        enemy_switch = []; // 적1 스위치 변수
        for(i=0;i<10;i++){
          enemy_switch [i] = 0;
        }

        let enemy_switch2 = []; // 적2 스위치 변수
        for(i=10;i<15;i++){
          enemy_switch2 [i] = 0;
        }



        let millisecond = 0; //밀리초 초기값을 0으로 지정
        let Timer_value = 0; //초 값을 0으로 지정

        let square_count = 1; //적사각형 남은 개수 초기값을 5로 지정

        let progress_status = 0; // 게임 진행상황 초기값 0으로 지정 1은 종료

        let start_timer = 0; // 타이머 변수 0은 멈춤, 1은 시작

        const enemyX = Array(15); // 적1 x y 좌표 배열 15개저장
        const enemyY = Array(15);

        /*const enemyX2 = [5]; // 적2 x y 좌표 배열 10개저장
        const enemyY2 = [5]; */

        //15번: 각각의 방향으로 이동하는함수들
        function moveRight(){
            x = x + moveAmount;
        }

        function moveLeft(){
            x = x - moveAmount;
        }

        function moveDown(){
            y = y + moveAmount;
        }

        function moveUp(){
            y = y - moveAmount;
        }

        // 1_4 주인공 이동제한
        function move_limit(){
          if (x < 0){//왼쪽이동제한
            x = 0;
          }
          if (x > 590){//오른쪽이동제한
            x = 590;
          }
          if (y < 0){//위쪽이동제한
            y = 0;
          }
          if (y > 590){//위쪽이동제한
            y = 590;    
          }
        }

        function showMessage(text) {
          msgText.innerText = text;
          msgBox.style.display = 'block';
          if(!userIdInput.value){
            userIdInput.value = '';
          }
          userIdInput.focus();
        }




        function collision1(){ // 적1 충돌검사 충돌하면 충돌변수에 1 저장
          for (i=0;i<10;i++){
            if (enemy_switch [i] == 1){
            if ((x+10)>enemyX [i] && (y+10)>enemyY [i] && x<(enemyX [i]+20) && y<(enemyY [i]+20)){
              collision_value [i] = 1; 
              decrease [i] = 1;
              enemy_switch [i] = 0;
            }
            }
          } 
        }

        function decrease_square(){ // 적사각형1 남은 개수 감소하는 함수
          for (i=0;i<10;i++){
            if (decrease [i] == 1){
            square_count --;
            decrease [i] = 0;
            }
          }
        }

        function collision2(){ // 적2 충돌검사 충돌하면 충돌변수에 1 저장
          for (i=10;i<15;i++){
            if (enemy_switch2 [i] == 1){
            if ((x+10)>enemyX [i] && (y+10)>enemyY [i] && x<(enemyX [i]+20) && y<(enemyY [i]+20)){
              collision_value2 [i] = 1; 
              enemy_switch2 [i] = 0;
              reset_enemy1();
            }
            }
          } 
        }

        function reset_enemy1(){ // 적사각형1을 초기화시키는 함수
          for (i=0;i<10;i++){
            collision_value [i] = 0;
            enemy_switch [i] = 1;
            square_count = 10;
          }
        }
        
        function enemy_random() {
        for (let i = 0; i < 15; i++) {
        let newX, newY, overlap;

        do {
        overlap = false;
        newX = 20 + Math.floor(Math.random() * (570 - 20 + 1));
        newY = 50 + Math.floor(Math.random() * (570 - 50 + 1));

        // 이미 뽑은 좌표들과 겹치는지 확인
        for (let j = 0; j < i; j++) {
          if (
            Math.abs(newX - enemyX[j]) < 30 &&
            Math.abs(newY - enemyY[j]) < 30
          ) {
            overlap = true;
            break;
          }
        }
      } while (overlap); // 겹치면 다시 뽑기

      enemyX[i] = newX;
      enemyY[i] = newY;
    }
  }

  enemy_random();


        /* function enemy_random(){ // 적1 x y 좌표 랜덤출력
            for(i=0;i<15;i++){
              enemyX [i] = 20 + Math.floor(Math.random() * (570 - 20 + 1));
              enemyY [i] = 50 + Math.floor(Math.random() * (570 - 50 + 1));
            }
        } */

        /* function enemy_random2(){ // 적2 x y 좌표 랜덤출력
            for(i=0;i<5;i++){
              enemyX2 [i] = 20 + Math.floor(Math.random() * (570 - 20 + 1));
              enemyY2 [i] = 50 + Math.floor(Math.random() * (570 - 50 + 1));
            }
        } */

      // enemy_random(); // 적사각형1 xy 좌표 난수 함수 호출
        // enemy_random2(); // 적사각형2 xy 좌표 난수 함수 호출

        function Timer(){ // 시간출력 함수
          if(start_timer === 1){
          millisecond ++;
          if (millisecond == 60){
            Timer_value ++;
            millisecond = 0;
          }
          }
        }

        function reload(){ // 페이지 새로고침 함수
          location.reload(true);
        }

        function hide_replayBtn(){ /* 재도전 버튼 숨기기 */
          if(progress_status == 0){
            document.getElementById("replayBtn").style.display = 'none';
          }
          else {
            document.getElementById("replayBtn").style.display = 'block';
          }
        }

        function click_startBtn(){ // 시작버튼을 누르면
          document.getElementById("startBtn").style.display = 'none';
          for(i=0;i<15;i++){
          collision_value[i] = 0;
          collision_value2[i] = 0;
          enemy_switch[i] = 1;
          enemy_switch2[i] = 1;
          start_timer = 1;
          x = 20;
          y = 570;
        }
      }

      function stop(){
        if(progress_status == 1){ // 게임이 종료되면
          start_timer = 0;
          for(i=0;i<15;i++){
            collision_value[i] = 1;
            collision_value2[i] = 1;
            enemy_switch[i] = 0;
            enemy_switch2[i] = 0;
          }
        }
      }


        // 1_4 : 캔버스 왼쪽 상단에 텍스트 출력함수
        function drawCoordinate(){
            drawingPen.fillStyle = 'black';
            drawingPen.font = '10px sans-serif';
            drawingPen.fillText(`x: ${x} y : ${y}`, 10, 20); //1_4 주인공 좌표출력
        }

        function draw_Timer(){ // 타이머를 출력하는 함수
          drawingPen.fillStyle = 'black';
          drawingPen.font = '20px sans-serif';
          drawingPen.fillText(`${Timer_value}:${millisecond}초`, 290, 30);
        }

        function draw_square_count(){ // 남은 적사각형 개수를 출력하는 함수
          drawingPen.fillStyle = 'black';
          drawingPen.font = '20px sans-serif';
          drawingPen.fillText(`RED no ${square_count}`, 400, 30);
        }
        //16번: 주인공(검정 사각형)을 그리는 함수
        function drawHero(){
            drawingPen.fillStyle = 'black';
            drawingPen.fillRect(x, y, 10, 10);
        }
        
        // 방향키 눌림 객체선언
        // const 값이 변하지 않고 속성(key)과 값(value)을 기억시킴
        // 내부 속성값 false는 true 또는 false로 변경가능함
        const keys = {
          ArrowLeft: false,
          ArrowRight: false,
          ArrowUp: false,
          ArrowDown: false
        };

        // 키보드를 keydown 시 처리
        document.addEventListener('keydown', (e) => {
          // e.key는 현재 선택한 키보드를 말함
          // hasOwnProperty는 keys변수안의 값이 있으면 true 없으면 false를 반환함.
          // e.key로 keys에 정의 한 키보드가 선택되면 true를 반환해서 아래 조건문을 만족
          // ArrowLeft: false를 true로 변경해서 function draw()함수 안쪽의 
          // if(keys.ArrowLeft) 조건이 true가 되고 moveLeft(); 왼쪽이동 함수를 이동해서
          // setInterval(draw, 16); 60FPS 만큼 캐릭터가 이동한다 즉 타이머 속도만큼 주인공이 이동한다
          if (keys.hasOwnProperty(e.key)) {
            keys[e.key] = true;
          }
        });

        // 키보드를 keyup 시 처리
        document.addEventListener('keyup', (e) => {
          // 해당키를 선택하다 keyup하면 해당키 값을 false로 변경해서 멈추게 된다.
          if (keys.hasOwnProperty(e.key)){
            // 키보드중 keys변수에 기록한 키보드가 keyup 되었을 때 값을 선택 되었다 false로 변경
            keys[e.key] = false;
          }
        });

        //적사각형1을 그리는 함수
        function enemy1(){
          for (i=0;i<10;i++){
            if(collision_value [i] == 0){
              drawingPen.fillStyle = 'red';
              drawingPen.fillRect(enemyX [i], enemyY [i], 20,20);
            }
          }
        }

        //적사각형2를 그리는 함수
        function enemy2(){
          for (i=10;i<15;i++){
            if(collision_value2 [i] == 0){
              drawingPen.fillStyle = 'blue';
              drawingPen.fillRect(enemyX [i], enemyY [i], 20,20);
            }
          }
        }

        function Gameover(){ // 게임종료 함수 
          if(square_count <= 0){
          drawingPen.fillStyle = 'red';
          drawingPen.font = '35px sans-serif';
          progress_status = 1;
          showMessage(`미션해결 시간 ${Timer_value}:${millisecond}초 \n저장 아이디((영어+숫자) 5~15자이내)를 입력하세요`);

          }
        }

        //17번: 화면을 지우고 주인공을 다시 그림
        function draw(){
            drawingPen.fillText(`x: ${x} y: ${y}`, 10, 20);// 1_4 : 캔버스 왼쪽 상단에 텍스트출력
            drawingPen.clearRect(0,0, canvas.width, canvas.height);
            drawHero(); // 새 위치에 주인공 그리기
            enemy1(); // 적1 출력 함수호출
            enemy2(); // 적2 출력 함수호출
            move_limit(); //1_4 : 주인공 이동제한 함수호출
            drawCoordinate(); // 1_4 : 텍스트 출력 함수 호출
            draw_Timer(); //타이머 출력 함수 호출
            collision1(); //적1 충돌검사 함수호출
            collision2(); //적2 충돌검사 함수호출
            Timer(); // 타이머 함수 호출
            stop(); // 게임이 끝났을 때 실행되는 함수 호출
            draw_square_count(); // 적사각형 남은개수 출력 함수 호출
            decrease_square(); // 적사각형 감소 함수 호출
            Gameover(); // 게임 종료 함수 호출
            hide_replayBtn(); // 재도전 버튼 함수 호출

        

        // 키가 눌려있는 동안 계속 이동(키보드 인식 속도 향상으로 이동을 부드럽게 변경)
        // 왼쪽 방향키를 선택해서 keys.ArrowLeft 값이 true 일때 처리
        if(keys.ArrowLeft) moveLeft();
        if(keys.ArrowRight) moveRight();
        if(keys.ArrowUp) moveUp();
        if(keys.ArrowDown) moveDown();
        }
                
        //18번: 1초에 60번 반복해서 draw 함수 실행 (움직임을 부드럽게 보여줌)

        setInterval(draw, 16); // 60 FPS

        // 19번 : 키보드를 누르면 해당 방향으로 이동하게 함
      /* document.addEventListener('keydown', (e) => {
        // 눌린 키(e.key)가 무엇인지 확인해서 아래 명령 실행
            switch (e.key) {
                case 'ArrowLeft' : moveLeft(); break; // 왼쪽 화살표 눌렀을 떄
                case 'ArrowRight' : moveRight(); break; // 오른쪽 화살표 눌렀을 때
                case 'ArrowUp' : moveUp(); break; // 위쪽 화살표 눌렀을 때
                case 'ArrowDown' : moveDown(); break; // 아래쪽 화살표 눌렀을 때
            }
        }
        );*/

        // 버튼 이벤트 연결 : 버튼을 선택하면 해당 함수를 호출해서 주인공 이동
        //  document : 현재 웹 페이지 전체를 의미
        //  hetElemenByld('leftBtn') : 웹 페이지에서 id가 leftBtn인 **버튼**을 의미
        //  addEventListener : "어떤 일이 일어났을 때" 실행할 코드를 지정해주는 함수
        //  'click' : 버튼을 마우스로 클릭했을 때 실행하라는 뜻임
        //  moveLeft : 클릭하면 moveLeft함수를 호출함
        document.getElementById('leftBtn').addEventListener('click', moveLeft);
        document.getElementById('rightBtn').addEventListener('click', moveRight);
        document.getElementById('upBtn').addEventListener('click', moveUp);
        document.getElementById('downBtn').addEventListener('click', moveDown);
        document.getElementById('replayBtn').addEventListener('click', reload);
        document.getElementById('startBtn').addEventListener('click', click_startBtn);
        

        </script>
    </body>
    </html>
    <!-- 주석문작성 : HTML 문서 끝-->
    <!-- html 이란? 
      웹사이트의 모습을 기술하기 위한 마크업 언어

      html5란?
      웹 페이지를 구성하기 위한 마크업 언어의 최신 표준

      canvas란?
      오픈 소스 학습 관리 시스템

      css란?
      html 등의 마크업 언어로 작성된 문서가 실제로 웹사이트에 표현되는 방법을 정해주는 스타일시트 언어

      반응형 홈페이지란?
      다양한 크기의 화면 (PC, 태블릿, 스마트폰 등) 에서 최적화된 화면 구성으로 보이는 웹페이지 -->

      <!-- 웹 호스팅이란?
      웹사이트의 파일, 데이터, 콘텐츠 등을 인터넷 서버에 저장하고 사용자들이 웹 브라우저를 통해 접속할 수 있도록 서비스를 제공하는 것을 의미
      URL이란?
      웹에서 특정 리소스(웹페이지, 이미지, 비디오 등)의 위치를 나타내는 주소
      IP주소란?
      IP 통신에 필요한 고유 주소
      도메인네임이란?
      인터넷에서 웹 사이트를 식별하고 접근하는 데 사용되는 문자열
      -->
